version: "3.9"  # facultatif mais explicite : version du schema Compose

services:
  db:
    container_name: db-beers
    build: ./sql                 # Construit une image "db" depuis ./sql (doit contenir un Dockerfile).
    restart: always              # Red√©marre automatiquement si le conteneur s'arr√™te inopin√©ment.
    ports:
      # MySQL √©coute en INTERNE sur 3306. On publie sur 3307 c√¥t√© h√¥te
      # pour √©viter les conflits avec un MySQL d√©j√† pr√©sent en local.
      - "3307:3306"
    environment:
      MYSQL_ROOT_PASSWORD: ${pass}
      MYSQL_DATABASE: ${database}
    # S'assurer que MySQL est bien UP avant de d√©marrer l'API
    healthcheck:
      # mysqladmin ping renvoie 0 quand le serveur est pr√™t.
      # -h localhost      : cible le serveur local dans le conteneur
      # -p${admin}        : mot de passe root (substitu√© depuis .env)
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-p${admin}"]
      interval: 5s       # fr√©quence entre checks
      timeout: 3s        # d√©lai max d'un check
      retries: 20        # nb d'essais avant de marquer "unhealthy"
      start_period: 10s  # d√©lai de gr√¢ce avant de commencer √† checker
    volumes:
      # Persistance des donn√©es MySQL : elles survivent aux recreates des conteneurs.
      - db_data:/var/lib/mysql
      # üëâ Si tu utilises l'image officielle MySQL, tu peux initialiser le sch√©ma
      # en montant des scripts SQL ici (ex√©cut√©s au premier d√©marrage) :
      # - ./sql/beer.sql:/docker-entrypoint-initdb.d/beer.sql:ro

  api:
    container_name: api-beer
    build: ./api                 # Construit l'image Flask depuis ./api (ton Dockerfile)
    ports:
      # Expose le port 5000 du conteneur sur 80 de l'h√¥te.
      - "80:5000"
    depends_on:
      # D√©marre 'api' seulement quand 'db' est "healthy".
      db:
        condition: service_healthy

volumes:
  db_data:                 # volume nomm√© pour la persistance du r√©pertoire de donn√©es MySQL
